<?php

/**********************************************

	Charry 0.9
	A Twitter client written in PHP-GTK
	
	Copyright (c) 2011 soren121.
	
	Licensed under the Microsoft Reciprocal
	License. The full text of the license 
	should be included; see LICENSE.txt.

**********************************************/

define('ABSPATH', dirname(__FILE__));

// Open settings file
$settings = simplexml_load_file(ABSPATH.'/settings.xml');
// Open TwitterOAuth library
require(ABSPATH.'/Twitter-PHP/OAuth.twitter.php');
// Open Twitter-PHP library
require(ABSPATH.'/Twitter-PHP/twitter.class.php');

// Start new GTK window
$window = new GtkWindow();
$window->set_title('Charry');
$window->set_size_request(430,600);
// Set quit handler
$window->connect_simple('destroy', array('Gtk', 'main_quit'));

// Add new vertical organizer
$vbox = new GtkVBox();
$window->add($vbox);

// Start new menubar
$menubar = new GtkMenuBar();
// Add menubar to organizer
$vbox->pack_start($menubar, false, false);
// Make the File and Options menu items
$ml_charry = new GtkMenuItem('_Charry');
$ml_options = new GtkMenuItem('_Options');
// Add the menu items to the menubar
$menubar->append($ml_charry);
$menubar->append($ml_options);
	// Make the File menu itself
	$m_charry = new GtkMenu();
	// Attach the File's menu to its menu item
	$ml_charry->set_submenu($m_charry);
		// Make the options 'Refresh' and 'Quit'
		$mi_refresh = new GtkMenuItem('_Refresh');
		$mi_quit = new GtkMenuItem('_Quit');
		// Attach a signal handler to make it work
		$mi_refresh->connect('activate', 'on_menu_select');
		$mi_quit->connect('activate', 'on_menu_select');
		// Add the options to the File menu
		$m_charry->append($mi_refresh);
		$m_charry->append($mi_quit);
	// Make the Options menu
	$m_options = new GtkMenu();
	// Attach the Options menu to its menu item
	$ml_options->set_submenu($m_options);
		// Make submenu item for displaying names
		$mi_options_display = new GtkMenuItem('Display Name');
		// Attach to Options
		$m_options->append($mi_options_display);
			// Make submenu for displaying names
			$m_options_display = new GtkMenu();
			// Attach to item
			$mi_options_display->set_submenu($m_options_display);
			// Make the (few) options
			$mi_username = new GtkRadioMenuItem(null, 'Username');
			$mi_realname = new GtkRadioMenuItem($mi_username, 'Real name');
			// Set the selected one
			switch($settings->ui->displayname) {
				case "screen_name":
					$mi_username->set_active(true);
					break;
				case "name":
					$mi_realname->set_active(true);
			}
			// Attach signal handler
			$mi_username->connect('toggled', 'on_menu_select');
			$mi_realname->connect('toggled', 'on_menu_select');
			// Attach to menu
			$m_options_display->append($mi_username);
			$m_options_display->append($mi_realname);

// Create new notebook (tabbed thingy)
$tabs = new GtkNotebook();
$tabs->set_tab_pos(Gtk::POS_LEFT);
$vbox->pack_start($tabs);

// Create page one, for normal timeline
$label_p1 = new GtkLabel('Timeline');
$label_p1->set_angle(90);
// Start scrolled window
$tweetScroll = new GtkScrolledWindow();
// Hide scrollbars when we don't need them
$tweetScroll->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
// Create new VBox
$tweets = new GtkVBox(false, 10);
// Add tweets to scrolled window
$tweetScroll->add_with_viewport($tweets);
// Add page to notebook
$tabs->append_page($tweetScroll, $label_p1);

// Create page 2, for searches
$label_p2 = new GtkLabel('Search');
$label_p2->set_angle(90);
$search_vbox = new GtkVBox();
$search_hbox = new GtkHBox();
$search = new GtkEntry();
$search_button = GtkButton::new_from_stock(Gtk::STOCK_OK);
$search->connect('activate', 'on_enter', $search_button);
$search_button->connect('clicked', 'on_click_search', $search);
// Start scrolled window
$searchScroll = new GtkScrolledWindow();
// Hide scrollbars when we don't need them
$searchScroll->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
// Create new VBox
$searchResults = new GtkVBox(false, 10);
// Add tweets to scrolled window
$searchScroll->add_with_viewport($searchResults);
// Add search widgets to horizontal box
$search_hbox->pack_start(new GtkLabel('Search terms: '), false, false);
$search_hbox->pack_start($search, true, true);
$search_hbox->pack_start($search_button, false, false);
$search_vbox->pack_start($search_hbox, false, false);
$search_vbox->pack_start($searchScroll, true, true);
$tabs->append_page($search_vbox, $label_p2);

// Create statusbar
$statusbar = new GtkStatusbar();
$eventbox = new GtkEventBox();
$eventbox->add($statusbar);
$vbox->pack_start($eventbox, false, false);

// Let the magic begin!
$window->show_all();

if(isset($settings->oauth->accessToken)) {
	// The secret: allow some time to load the window, then stop and load tweets
	// Open up a Twitter connection
	$twitter = new Twitter(utf8_encode($settings->oauth->consumerToken), utf8_encode($settings->oauth->consumerSecret), utf8_encode($settings->oauth->accessToken), utf8_encode($settings->oauth->accessSecret));
	// Run load_tweets() once when idle
	$idle_id = Gtk::idle_add('load_tweets_first');
	// And then every 5 minutes after that (when idle)
	Gtk::timeout_add(300000, 'load_tweets');
}
else {
	// Charry needs to authenticate with Twitter first
	Gtk::idle_add('twitter_oAuth');
}

Gtk::main();

function twitter_oAuth() {
	global $settings, $twitter, $statusbar;
	// Tell the user that we're actually doing something!
	$statusbar->push($statusbar->get_context_id('start'), 'Obtaining request tokens from Twitter...');
	// Update the UI
	while(Gtk::events_pending()) {
		Gtk::main_iteration();
	}
	// Open a new TwitterOAuth object so we can get started
	$oauth = new TwitterOAuth(utf8_encode($settings->oauth->consumerToken), utf8_encode($settings->oauth->consumerSecret));
	// Ask Twitter for request tokens so we can start authenticating
	$request = $oauth->getRequestToken();
	// Save the request tokens to our settings file
	$settings->oauth->requestToken = $request['oauth_token'];
	$settings->oauth->requestSecret = $request['oauth_token_secret'];
	$settings->asXML(ABSPATH.'/settings.xml');
	// Get an authentication URL from Twitter
	$request_link = $oauth->getAuthorizeURL($request);
	// Open browser
	$os = explode(' ', php_uname('s'));
	// Figure out what OS the user is using so we can open their browser
	switch($os[0]) {
		case "Windows":
			exec('cmd /c start '.$request_link);
			break;
		case "Darwin":
			exec('open '.$request_link);
			break;
		default:
			exec('xdg-open '.$request_link);
	}
	// Open prompt for user to enter in the PIN from Twitter
	$prompt = new Prompt('Enter PIN: ');
	$input = $prompt->entry->get_text();
	// New TwitterOAuth object: this time with all the fixings
	$oauth = new TwitterOAuth(utf8_encode($settings->oauth->consumerToken), utf8_encode($settings->oauth->consumerSecret), utf8_encode($settings->oauth->requestToken), utf8_encode($settings->oauth->requestSecret));
	// Politely ask Twitter for an access token
	$request = $oauth->getAccessToken($input);
	// Yay, we got access tokens! :D
	$settings->oauth->accessToken = $request['oauth_token'];
	$settings->oauth->accessSecret = $request['oauth_token_secret'];
	$settings->asXML(ABSPATH.'/settings.xml');
	// Verify that we did everything right
	$twitter = new Twitter(utf8_encode($settings->oauth->consumerToken), utf8_encode($settings->oauth->consumerSecret), utf8_encode($settings->oauth->accessToken), utf8_encode($settings->oauth->accessSecret));
	if($twitter->authenticate()) {
		$statusbar->push($statusbar->get_context_id('fin'), 'Successfully authenticated with Twitter!');
		// Update the UI
		while(Gtk::events_pending()) {
			Gtk::main_iteration();
		}
		// Load the timeline!
		load_tweets();
	}
	return false;
}

function load_tweets_first() {
	global $idle_id;
	load_tweets();
	Gtk::idle_remove($idle_id);
	unset($idle_id);
}

function load_tweets($search = null) {
	global $twitter, $settings, $tweets, $idle_id, $first_run, $statusbar;
	// Tell the user that we're actually doing something!
	$statusbar->push($statusbar->get_context_id('start'), 'Loading timeline...');
	// Update the UI
	while(Gtk::events_pending()) {
    	Gtk::main_iteration();
	}
	// If we're searching, we have to change some things up
	if(isset($search)) {
		// Load tweets for search result, defaults to 15
		global $searchResults;
		$tweets = $searchResults;
		$results = $twitter->search($search);
	}
	// Normal timeline load it is!
	else {
		// Load tweets from you & people you've followed, defaults to 20
		$results = $twitter->load(Twitter::ME_AND_FRIENDS)->status;
	}
	// Clear out anything that's there already
	foreach($tweets->get_children() as $child) {
		$child->destroy();
	}
	// Load up them tweets!
	foreach($results as $status) {
		// Compatibility for searches
		if($search != false) {
			$status->user->screen_name = $status->from_user;
			$status->user->name = $status->from_user;
			$status->user->profile_image_url = $status->profile_image_url;
		}
		// If this user's avatar isn't cached, cache it!
		if(!file_exists(ABSPATH.'/cache/images/'.$status->user->screen_name.'.cache')) {
			file_put_contents(ABSPATH.'/cache/images/'.$status->user->screen_name.'.cache', file_get_contents(htmlspecialchars($status->user->profile_image_url)));
		}
		// Load the avatar from the cache
		$avatar_pb = GdkPixbuf::new_from_file(ABSPATH.'/cache/images/'.$status->user->screen_name.'.cache');
		if($avatar_pb->get_width() > 48) {
			// This avatar isn't 48 pixels like the API promised! Let's scale it down.
			$avatar_pb = $avatar_pb->scale_simple(48, 48, Gdk::INTERP_HYPER);
		}
		$avatar = GtkImage::new_from_pixbuf($avatar_pb);
		// Make their username a GTK label, justified left.
		$name = new GtkLabel();
		$name->set_alignment(0, 0);
		$name_type = $settings->ui->displayname;
		$name->set_markup('<b>'.utf8_decode($status->user->$name_type).'</b>');
		// Make their tweet a GTK label, justified left, selectable, and wrapable.
		$text = new GtkLabel();
		$text->set_justify(Gtk::JUSTIFY_LEFT);
		$text->set_alignment(0, 0);
		$text->set_selectable(true);
		$text->set_line_wrap(true);
		$text->set_size_request(300, -1);
		$text->set_markup($twitter->clickable(utf8_decode($status->text)));
		// Make the date and time a <small> GTK label, justified left and selectable.
		$datetime = new GtkLabel();
		$datetime->set_alignment(0, 0);
		$datetime->set_selectable(true);
		$datetime->set_markup('<small>'.date('l, F j Y \a\t g:i a', strtotime($status->created_at)).'</small>');
		// Make containers for tweet
		$tweetBox = new GtkHBox();
		$tweetBox_inner = new GtkVBox();
		$tweetBox->pack_end($tweetBox_inner);
		// Set container attributes
		$tweetBox->set_size_request(370, -1);
		// Add stuff to it
		$tweetBox->pack_start($avatar);
		$tweetBox_inner->pack_start($name, false, false);
		$tweetBox_inner->pack_start($text, false, false);
		$tweetBox_inner->pack_start($datetime, false, false);
		// Add tweet box to tweets window
		$tweets->pack_start($tweetBox);
	}
	// Show all loaded tweets
	$tweets->show_all();
	// Update statusbar
	$statusbar->push($statusbar->get_context_id('fin'), 'Loaded '.count($results).' tweets.');
	return true;
}

// Do something if the user selects a menu item
function on_menu_select($item) {
	global $settings;
	// Get the label of the menu item
	$item = $item->child->get_label();
	switch($item) {
		case "_Refresh":
			// Load new tweets
			load_tweets();
			break;
		case "_Quit":
			// Self-explanatory
			Gtk::main_quit();
			break;
		case "Username":
			// Set the display name option to 'screen_name' and save
			$settings->ui->displayname = 'screen_name';
			$settings->asXML(ABSPATH.'/settings.xml');
			break;
		case "Real name":
		// Set the display name option to 'name' and save
			$settings->ui->displayname = 'name';
			$settings->asXML(ABSPATH.'/settings.xml');
	}
}

// Process tweet submission
function on_key_press($widget, $event, $sbox, $sboxB, $tweets) {
	global $twitter, $statusbar;
	// Did the user press Enter?
	if($event->keyval == Gdk::KEY_Return) {
		// If they pressed Shift+Enter, treat it as a new line
		if($event->state & Gdk::SHIFT_MASK) {
			return false;
		}
		// Set statusbar
		$statusbar->push($statusbar->get_context_id('submit'), 'Submitting tweet...');
		// Get text from the submit box
		$input = $sboxB->get_text($sboxB->get_start_iter(), $sboxB->get_end_iter());
		// Empty out the submit box
		$sboxB->set_text('');
		// Update the UI
		while(Gtk::events_pending()) {
			Gtk::main_iteration();
		}
		// Encode and send to Twitter!
		$twitter->send(utf8_encode($input));
		// Reload timeline
		load_tweets();
		return true;
	}
	// I guess not :(
	else {
		return false;
	}
}

// If the user presses Enter in a GtkEntry, perform a click action on the button to submit it
function on_enter($entry, $button) {
	$button->clicked();
}

// When the search button is clicked (manually or artificially), load tweets with the provided query
function on_click_search($button, $entry) {
	// Twitter doesn't like empty search queries, so don't give them one
	if($entry->get_text() != '') {
		load_tweets($entry->get_text());
	}
}

// Prompt class copied verbatim from the PHP-GTK Cookbook <http://www.kksou.com/php-gtk2>
// May or may not work, not entirely sure
class Prompt {
	var $entry;
	function Prompt($str) {
		$dialog = new GtkDialog('Prompt', null, Gtk::DIALOG_MODAL);
		$top_area = $dialog->vbox;
		$top_area->pack_start($hbox = new GtkHBox());
		$stock = GtkImage::new_from_stock(Gtk::STOCK_DIALOG_QUESTION, Gtk::ICON_SIZE_DIALOG);
		$hbox->pack_start($stock, 0, 0);
		$hbox->pack_start(new GtkLabel($str));
		$this->entry = new GtkEntry();
		$hbox->pack_start($this->entry, 0, 0);
		$hbox->pack_start(new GtkLabel(' '), 0, 0);
	
		$dialog->add_button(Gtk::STOCK_OK, Gtk::RESPONSE_OK);
	
		$buttons = $dialog->action_area->get_children();
		$button_ok = $buttons[0]; // get the ID of the OK button
		// simulate button click when user press enter
		$this->entry->connect('activate', array(&$this, 'on_enter'), $button_ok);
	
		$dialog->set_has_separator(false);
		$dialog->show_all();
		$dialog->run();
		$dialog->destroy();
	}
	
	function on_enter($entry, $button) {
		$button->clicked();
	}
}

?>
